# 최단 경로 알고리즘

* Shortest Path 알고리즘
* 말그대로 가장 짧은 경로를 찾는 알고리즘.
* **길찾기** 문제라고도 불림.


## 의문
* Binary-First Search 알고리즘, 너비 우선 탐색을 통해 우리가 이미 구할 수 있음.
* BFS를 통해 구한 경로는 항상 최단경로이기 때문.
    * 시작노드에서 부터 거리가 얼마인지 구하는 프로그램이기 때문.
    * Depth-First Search 알고리즘, 깊이 우선 탐색에서는 최단경로라는 보장이 없음.

* **그러면 우리는 왜 BFS을 사용하지 않는가?**
    1. 가중치가 있는 그래프에선 BFS가 최적의 경로를 보장하지 않음.  
        <img src='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fbf2pPR%2FbtsgJ0wm605%2Ffri1ORDerQjITaYe2WBIKk%2Fimg.jpg' width=400 height=200>  
        [참고](https://deulee.tistory.com/m/11)
        * 위에서 A가 시작 노드라고 가정.
        * BFS가 작동하면 큐에 순서대로 (2,B), (12,C)가 저장.
        * 그리고 D방문 후 종료.
        
        </br>

        * 여기서 A에서 C까지의 최적의 경로는?
        * BFS는 시작노드부터 거리가 1인 A->C를 선택.
        * 하지만, 비용측면에서 보게 된다면, A->B->D->C가 비용을 덜 사용하게 됨.
        * **즉, 최적의 해가 아니다!**
        * BFS는 가중치가 1 or 0인 경우에만 사용.


    2. 가중치가 음수인 경우에도 위와 같은 이유로 BFS를 사용하지 못함.

## 해결방법
* 1번의 문제의 경우에는 __다익스트라 알고리즘__ 통해 해결할 수 있다.
* 2번의 문제는 **벨만 포드 알고리즘 혹은 플로이드-워셜 알고리즘**을 통해 해결할 수 있다.

</br>

## 다익스트라 알고리즘
* Greedy 알고리즘
* 음의 가중치가 없는 그래프의 한 노드에서 가중치의 합의 최소가 되는 경로.
* 하나의 노드로부터 최단경로를 구하는 알고리즘.

### 구현
* 방문하지 않은 노드 중 최단 거리인 노드를 선택하는 과정을 반복.
* 각 단계별로 선택된 노드는 인접된 노드들의 최단경로를 갱신하고, 그 뒤는 더 작은 값으로 다시 갱신되지 않음.
* 도착 노드는 다른 노드를 거쳐 가는 길을 찾을 필요가 없음.


* 다익스트라 확장 버전으로 A*알고리즘이 있다.


## 벨만 포드 알고리즘


## 플로이드-워셜 알고리즘
* 모든 노드쌍에 대한 최단거리를 구하는 알고리즘.
